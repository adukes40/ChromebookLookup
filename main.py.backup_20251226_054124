"""
Chromebook Dashboard - Main Application
Combines IncidentIQ asset data with Google Workspace device information
"""

from fastapi import FastAPI, HTTPException, Request, Depends
from fastapi.responses import HTMLResponse, RedirectResponse, Response
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.sessions import SessionMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
from authlib.integrations.starlette_client import OAuth
import redis
import json
import os
from datetime import datetime
from typing import Optional, Dict, List
import logging

# Load environment variables
from dotenv import load_dotenv
load_dotenv('/opt/chromebook-dashboard/.env')

# Database imports
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.pool import QueuePool

# Database Configuration
DB_HOST = os.getenv('DB_HOST', 'localhost')
DB_PORT = os.getenv('DB_PORT', '5432')
DB_NAME = os.getenv('DB_NAME', 'chromebook_dashboard')
DB_USER = os.getenv('DB_USER', 'chromebook_user')
DB_PASSWORD = os.getenv('DB_PASSWORD', '')

DATABASE_URL = f"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"

# Create database engine
engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=10,
    max_overflow=20,
    pool_pre_ping=True
)

# Create session maker
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    """Get database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# OAuth Configuration
GOOGLE_CLIENT_ID = os.getenv('GOOGLE_CLIENT_ID')
GOOGLE_CLIENT_SECRET = os.getenv('GOOGLE_CLIENT_SECRET')
SECRET_KEY = os.getenv('SECRET_KEY')
ALLOWED_DOMAIN = os.getenv('ALLOWED_DOMAIN', 'cr.k12.de.us')
ALLOWED_GROUP = os.getenv('ALLOWED_GROUP', '') # Google Group email
REDIRECT_URI = os.getenv('REDIRECT_URI')

# Google API imports
from google.oauth2 import service_account
from googleapiclient.discovery import build

# IncidentIQ integration
from integrations.incidentiq import IncidentIQClient

# Meraki integration
from integrations.meraki import MerakiClient

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize FastAPI
app = FastAPI(title="Chromebook Dashboard", version="1.0.0")

# Add cache control middleware for static files
class NoCacheMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)

        # Add no-cache headers for JS and CSS files
        if request.url.path.endswith(('.js', '.css')):
            response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
            response.headers['Pragma'] = 'no-cache'
            response.headers['Expires'] = '0'

        return response

app.add_middleware(NoCacheMiddleware)

# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")

# Templates
templates = Jinja2Templates(directory="templates")

# Session middleware for authentication
app.add_middleware(SessionMiddleware, secret_key=SECRET_KEY)

# OAuth setup
oauth = OAuth()
oauth.register(
    name='google',
    client_id=GOOGLE_CLIENT_ID,
    client_secret=GOOGLE_CLIENT_SECRET,
    server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
    client_kwargs={'scope': 'openid email profile'}
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Authentication dependency
async def get_current_user(request: Request):
    user = request.session.get('user')
    if not user:
        raise HTTPException(status_code=401, detail="Not authenticated")
    return user

# Redis connection
redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)

# Configuration from environment
SERVICE_ACCOUNT_FILE = os.getenv('GOOGLE_SERVICE_ACCOUNT_FILE', '/opt/chromebook-dashboard/credentials.json')
DELEGATED_ADMIN_EMAIL = os.getenv('GOOGLE_ADMIN_EMAIL', '')
CACHE_TTL = int(os.getenv('CACHE_TTL', '300'))

# IncidentIQ Configuration
INCIDENTIQ_SITE_ID = os.getenv('INCIDENTIQ_SITE_ID', '')
INCIDENTIQ_API_TOKEN = os.getenv('INCIDENTIQ_API_TOKEN', '')
INCIDENTIQ_PRODUCT_ID = os.getenv('INCIDENTIQ_PRODUCT_ID', '88df910c-91aa-e711-80c2-0004ffa00050')

# Meraki Configuration
MERAKI_API_KEY = os.getenv('MERAKI_API_KEY', '')
MERAKI_ORG_ID = os.getenv('MERAKI_ORG_ID', '')

# Google API scopes
SCOPES = [
    'https://www.googleapis.com/auth/admin.directory.device.chromeos.readonly',
    'https://www.googleapis.com/auth/admin.directory.user.readonly',
    'https://www.googleapis.com/auth/admin.directory.orgunit.readonly',
    'https://www.googleapis.com/auth/admin.directory.group.member.readonly'
]

def get_google_service():
    """Create Google Admin SDK service"""
    try:
        if not os.path.exists(SERVICE_ACCOUNT_FILE):
            raise HTTPException(status_code=500, detail="Service account file not found")
        
        credentials = service_account.Credentials.from_service_account_file(
            SERVICE_ACCOUNT_FILE,
            scopes=SCOPES
        )
        
        if DELEGATED_ADMIN_EMAIL:
            credentials = credentials.with_subject(DELEGATED_ADMIN_EMAIL)
        
        return build('admin', 'directory_v1', credentials=credentials)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create Google service: {str(e)}")

def format_mac_address(mac: str) -> str:
    """Format MAC address to XX:XX:XX:XX:XX:XX"""
    if not mac or mac == 'N/A':
        return 'N/A'
    
    clean_mac = mac.replace(':', '').replace('-', '').replace('.', '').upper()
    
    if len(clean_mac) == 12:
        return ':'.join(clean_mac[i:i+2] for i in range(0, 12, 2))
    
    return mac

def get_google_device_by_serial(service, serial_number: str) -> Optional[Dict]:
    """Get Google device by serial number using query"""
    try:
        results = service.chromeosdevices().list(
            customerId='my_customer',
            query=f'id:{serial_number}',
            projection='FULL',
            maxResults=1
        ).execute()
        
        devices = results.get('chromeosdevices', [])
        if devices:
            return devices[0]
        
        return None
        
    except Exception as e:
        logger.error(f"Error fetching Google device {serial_number}: {e}")
        return None


def get_google_user(service, email: str) -> Optional[Dict]:
    """Get Google user info"""
    try:
        user = service.users().get(userKey=email, projection='full').execute()
        return user
    except Exception as e:
        logger.error(f"Error fetching Google user {email}: {e}")
        return None

def get_user_chromebook_history(service, email: str, iiq_client) -> List[Dict]:
    """Get Chromebooks this user has logged into with asset tags from IIQ"""
    try:
        # Search for devices where this user appears in recentUsers
        results = service.chromeosdevices().list(
            customerId='my_customer',
            projection='FULL',
            maxResults=100
        ).execute()
        
        devices = results.get('chromeosdevices', [])
        user_devices = []
        
        for device in devices:
            recent_users = device.get('recentUsers', [])
            for recent_user in recent_users:
                if recent_user.get('email', '').lower() == email.lower():
                    serial = device.get('serialNumber', 'N/A')
                    
                    # Try to get asset tag from IIQ
                    asset_tag = 'N/A'
                    asset_id = ''
                    if serial != 'N/A':
                        iiq_results = iiq_client.search_and_extract(serial, limit=1)
                        if iiq_results:
                            asset_tag = iiq_results[0].get('assetTag', 'N/A')
                            asset_id = iiq_results[0].get('assetId', '')
                    
                    user_devices.append({
                        'assetTag': asset_tag,
                        'assetId': asset_id,
                        'serialNumber': serial,
                        'model': device.get('model', 'N/A'),
                        'lastSync': device.get('lastSync', 'N/A'),
                        'orgUnitPath': device.get('orgUnitPath', 'N/A')
                    })
                    break
        
        # Sort by most recent and limit to 10
        return user_devices[:10]
        
    except Exception as e:
        logger.error(f"Error fetching user device history: {e}")
        return []


@app.get("/login")
async def login(request: Request):
    """Redirect to Google login"""
    redirect_uri = REDIRECT_URI
    return await oauth.google.authorize_redirect(request, redirect_uri)

@app.get("/auth/callback")
async def auth_callback(request: Request):
    """Handle Google OAuth callback"""
    try:
        token = await oauth.google.authorize_access_token(request)
        user_info = token.get('userinfo')
        
        # Check domain
        email = user_info.get('email', '')
        if not email.endswith(f'@{ALLOWED_DOMAIN}'):
            raise HTTPException(status_code=403, detail=f"Only {ALLOWED_DOMAIN} emails allowed")
        
        # Check group membership if specified
        if ALLOWED_GROUP:
            try:
                google_service = get_google_service()
                
                # Check if user is in the allowed group (including nested groups)
                try:
                    # hasMember checks both direct and nested membership
                    result = google_service.members().hasMember(
                        groupKey=ALLOWED_GROUP,
                        memberKey=email
                    ).execute()
                    
                    if result.get('isMember'):
                        logger.info(f"User {email} is member of {ALLOWED_GROUP} (direct or nested)")
                    else:
                        logger.warning(f"User {email} not in group {ALLOWED_GROUP}")
                        raise HTTPException(
                            status_code=403, 
                            detail=f"Access denied. You must be a member of {ALLOWED_GROUP}"
                        )
                except HTTPException:
                    raise
                except Exception as e:
                    logger.error(f"Error checking group membership for {email}: {e}")
                    raise HTTPException(
                        status_code=403, 
                        detail=f"Access denied. Could not verify group membership."
                    )
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Error checking group membership: {e}")
                raise HTTPException(status_code=500, detail="Authentication error")
        
        # Store user in session
        request.session['user'] = {
            'email': email,
            'name': user_info.get('name'),
            'picture': user_info.get('picture')
        }
        
        return RedirectResponse(url='/')
    except Exception as e:
        logger.error(f"Auth error: {e}")
        raise HTTPException(status_code=400, detail="Authentication failed")

@app.get("/logout")
async def logout(request: Request):
    """Logout user"""
    request.session.clear()
    return RedirectResponse(url='/login')

@app.get("/api/health")
async def health_check(user: dict = Depends(get_current_user), ):
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "redis": redis_client.ping(),
        "google_configured": os.path.exists(SERVICE_ACCOUNT_FILE),
        "incidentiq_configured": bool(INCIDENTIQ_SITE_ID and INCIDENTIQ_API_TOKEN)
    }

@app.get("/api/dashboard/stats")
async def dashboard_stats(user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    """Get dashboard analytics from database - instant results"""
    try:
        # Query database for stats (much faster than API calls)
        query = text("""
            SELECT
                COUNT(*) as total_devices,
                COUNT(CASE WHEN status = 'ACTIVE' THEN 1 END) as active,
                COUNT(CASE WHEN status = 'DISABLED' THEN 1 END) as disabled,
                COUNT(CASE WHEN status = 'PROVISIONED' THEN 1 END) as provisioned,
                COUNT(CASE WHEN status = 'DEPROVISIONED' THEN 1 END) as deprovisioned,
                MAX(updated_at) as last_sync
            FROM chromebooks
        """)

        result = db.execute(query).fetchone()

        stats = {
            "total_devices": result[0],
            "active": result[1],
            "disabled": result[2],
            "provisioned": result[3],
            "deprovisioned": result[4],
            "last_sync": result[5].isoformat() if result[5] else None,
            "timestamp": datetime.utcnow().isoformat()
        }

        return stats

    except Exception as e:
        logger.error(f"Dashboard stats error: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch stats: {str(e)}")

@app.get("/api/combined/search")
async def combined_search(user: dict = Depends(get_current_user), query: str = "", db: Session = Depends(get_db)):
    """IIQ-first search - real-time data from IIQ API, merged with cached Google data for chromebooks"""
    try:
        if not query:
            return {"devices": [], "count": 0, "source": "none"}

        # STEP 1: Search IIQ API in real-time (all asset types)
        iiq_client = IncidentIQClient(INCIDENTIQ_SITE_ID, INCIDENTIQ_API_TOKEN, INCIDENTIQ_PRODUCT_ID)
        iiq_results = iiq_client.search_and_extract(query, limit=50)

        if not iiq_results:
            return {"devices": [], "count": 0, "source": "iiq"}

        # STEP 2: For chromebooks only, fetch cached Google data from database
        # Build list of serial numbers for chromebooks
        chromebook_serials = [
            asset['serialNumber'] for asset in iiq_results
            if asset.get('isChromebook') and asset.get('serialNumber') != 'N/A'
        ]

        # Query database for Google data (if any chromebooks found)
        google_data_lookup = {}
        if chromebook_serials:
            google_query = text("""
                SELECT
                    serial_number,
                    device_id,
                    status as google_status,
                    org_unit_path,
                    mac_address,
                    ip_address,
                    os_version,
                    last_used_date,
                    annotated_user,
                    recent_users,
                    meraki_ap_name,
                    meraki_network,
                    last_seen_meraki,
                    battery_health,
                    battery_cycle_count,
                    platform_version,
                    firmware_version,
                    wan_ip_address
                FROM chromebooks
                WHERE serial_number = ANY(:serials)
            """)

            google_results = db.execute(google_query, {"serials": chromebook_serials}).fetchall()
            google_data_lookup = {row[0]: row for row in google_results}

        # STEP 3: Merge IIQ data with Google data
        devices = []
        for iiq_asset in iiq_results:
            serial = iiq_asset.get('serialNumber', 'N/A')
            is_chromebook = iiq_asset.get('isChromebook', False)

            # Base device data from IIQ (real-time)
            device = {
                'assetId': iiq_asset.get('assetId', ''),
                'assetTag': iiq_asset.get('assetTag', 'N/A'),
                'serialNumber': serial,
                'model': iiq_asset.get('model', 'N/A'),
                'deviceType': iiq_asset.get('deviceType', 'Unknown'),
                'iiqStatus': iiq_asset.get('status', 'N/A'),
                'iiqOwnerEmail': iiq_asset.get('assignedUserEmail', ''),
                'iiqOwnerName': iiq_asset.get('assignedUser', 'Not assigned'),
                'iiqOwnerStudentId': iiq_asset.get('assignedUserStudentId', ''),
                'location': iiq_asset.get('location', 'N/A'),
                'source': 'iiq'
            }

            # If chromebook, merge with Google data from database (cached)
            if is_chromebook and serial in google_data_lookup:
                google_row = google_data_lookup[serial]

                # Parse recent_users JSON
                recent_users_json = google_row[9] if google_row[9] else []
                if isinstance(recent_users_json, str):
                    import json as json_lib
                    recent_users_json = json_lib.loads(recent_users_json)

                recent_user_emails = [u.get('email', '') for u in recent_users_json[:5]] if recent_users_json else []
                last_known_user = recent_user_emails[0] if recent_user_emails else device['iiqOwnerEmail'] or 'N/A'

                device.update({
                    'deviceId': google_row[1] or '',
                    'googleStatus': google_row[2] or 'N/A',
                    'orgUnitPath': google_row[3] or 'N/A',
                    'macAddress': format_mac_address(google_row[4]) if google_row[4] else 'N/A',
                    'ipAddress': google_row[5] or 'N/A',
                    'osVersion': google_row[6] or 'N/A',
                    'lastSync': google_row[7].isoformat() if google_row[7] else 'N/A',
                    'assignedUser': google_row[8] or device['iiqOwnerEmail'],
                    'recentUsers': recent_user_emails,
                    'merakiApName': google_row[10],
                    'merakiNetwork': google_row[11],
                    'merakiLastSeen': google_row[12].isoformat() if google_row[12] else None,
                    'batteryHealth': google_row[13],
                    'batteryCycleCount': google_row[14],
                    'platformVersion': google_row[15] or 'N/A',
                    'firmwareVersion': google_row[16] or 'N/A',
                    'wanIpAddress': google_row[17] or 'N/A',
                    'lastKnownUser': last_known_user,
                    'source': 'iiq+google'
                })
            else:
                # Non-chromebook or chromebook without Google data: set defaults
                device.update({
                    'deviceId': '',
                    'googleStatus': 'N/A',
                    'macAddress': 'N/A',
                    'ipAddress': 'N/A',
                    'wanIpAddress': 'N/A',
                    'osVersion': 'N/A',
                    'lastSync': 'N/A',
                    'orgUnitPath': 'N/A',
                    'assignedUser': device['iiqOwnerEmail'],
                    'recentUsers': [],
                    'lastKnownUser': device['iiqOwnerEmail'],
                    'merakiApName': None,
                    'merakiNetwork': None,
                    'merakiLastSeen': None,
                })

            devices.append(device)

        return {"devices": devices, "count": len(devices), "source": "iiq+google"}

    except Exception as e:
        logger.error(f"Search error: {e}")
        raise HTTPException(status_code=500, detail=f"Search failed: {str(e)}")


@app.get("/api/user/search")
async def user_search(user: dict = Depends(get_current_user), query: str = "", db: Session = Depends(get_db)):
    """Enhanced user search using IIQ API - supports first name, last name, email, ID number"""
    try:
        if not query:
            return {"users": [], "count": 0}

        # Initialize IIQ client
        iiq_client = IncidentIQClient(INCIDENTIQ_SITE_ID, INCIDENTIQ_API_TOKEN, INCIDENTIQ_PRODUCT_ID)

        # IIQ-FIRST: Search users via IIQ API (supports first/last name, email, ID)
        iiq_users = iiq_client.search_and_extract_users(query, limit=20)

        logger.info(f"IIQ user search for '{query}' returned {len(iiq_users)} users")

        users_list = []
        for iiq_user in iiq_users:
            email = iiq_user.get('email', '').lower()
            user_id = iiq_user.get('userId', '')

            # Skip if no user ID (can't fetch assignments without it)
            if not user_id:
                continue

            # REAL-TIME: Fetch IIQ assigned devices from IIQ API
            iiq_assigned_assets = iiq_client.get_user_assets(user_id)
            logger.info(f"User {email} has {len(iiq_assigned_assets)} assigned devices in IIQ")

            # Get Google recent logins (from recent_users JSON) - limit to 5 most recent
            google_recent_query = text("""
                SELECT
                    device_id,
                    asset_tag,
                    serial_number,
                    model,
                    status,
                    iiq_location,
                    iiq_room,
                    iiq_status,
                    iiq_asset_id,
                    mac_address,
                    ip_address,
                    wan_ip_address,
                    os_version,
                    battery_health,
                    last_used_date,
                    recent_users
                FROM chromebooks
                WHERE recent_users::text LIKE :email_pattern
                ORDER BY last_used_date DESC NULLS LAST
                LIMIT 5
            """)

            google_devices_results = db.execute(google_recent_query, {"email_pattern": f"%{email}%"}).fetchall()

            # Process IIQ assigned devices - merge with Google data
            iiq_assigned_devices = []
            for asset in iiq_assigned_assets:
                # Extract basic IIQ asset info
                serial = asset.get('SerialNumber', '').upper()
                asset_tag = asset.get('AssetTag', 'N/A')
                asset_id = asset.get('AssetId', '')

                # Extract model
                model_obj = asset.get('Model', {})
                model_name = model_obj.get('Name', 'N/A') if isinstance(model_obj, dict) else str(model_obj)

                # Extract category (device type)
                category = model_obj.get('Category', {}) if isinstance(model_obj, dict) else {}
                device_type = category.get('Name', 'Unknown') if isinstance(category, dict) else 'Unknown'

                # Extract location
                location_obj = asset.get('Location', {})
                location = location_obj.get('Name', 'N/A') if isinstance(location_obj, dict) else 'N/A'
                room = asset.get('LocationRoomId', 'N/A')

                # Extract status
                status_obj = asset.get('Status', {})
                iiq_status = status_obj.get('Name', 'N/A') if isinstance(status_obj, dict) else 'N/A'

                # Try to find matching Google data by serial number
                google_data_query = text("""
                    SELECT device_id, mac_address, ip_address, wan_ip_address,
                           os_version, battery_health, last_used_date, status
                    FROM chromebooks
                    WHERE UPPER(serial_number) = :serial
                    LIMIT 1
                """)
                google_match = db.execute(google_data_query, {"serial": serial}).fetchone()

                # Build device info with IIQ as source of truth, enhanced with Google data
                device_info = {
                    'deviceId': google_match[0] if google_match else '',
                    'assetTag': asset_tag,
                    'serialNumber': serial or 'N/A',
                    'model': model_name,
                    'googleStatus': google_match[7] if google_match else 'N/A',
                    'location': location,
                    'room': room,
                    'iiqStatus': iiq_status,
                    'iiqAssetId': asset_id,
                    'macAddress': format_mac_address(google_match[1]) if (google_match and google_match[1]) else 'N/A',
                    'ipAddress': google_match[2] if google_match else 'N/A',
                    'wanIpAddress': google_match[3] if google_match else 'N/A',
                    'osVersion': google_match[4] if google_match else 'N/A',
                    'batteryHealth': google_match[5] if google_match else None,
                    'lastSync': google_match[6].isoformat() if (google_match and google_match[6]) else 'N/A',
                    'deviceType': device_type,
                    'source': 'iiq_assigned'
                }
                iiq_assigned_devices.append(device_info)

            # Process Google recent logins
            google_recent_devices = []
            for dev in google_devices_results:
                # Skip if already in IIQ assigned list
                if dev[2] in [d['serialNumber'] for d in iiq_assigned_devices]:
                    continue

                device_info = {
                    'deviceId': dev[0] or '',
                    'assetTag': dev[1] or 'N/A',
                    'serialNumber': dev[2] or 'N/A',
                    'model': dev[3] or 'N/A',
                    'googleStatus': dev[4] or 'N/A',
                    'location': dev[5] or 'N/A',
                    'room': dev[6] or 'N/A',
                    'iiqStatus': dev[7] or 'N/A',
                    'iiqAssetId': dev[8] or '',
                    'macAddress': format_mac_address(dev[9]) if dev[9] else 'N/A',
                    'ipAddress': dev[10] or 'N/A',
                    'wanIpAddress': dev[11] or 'N/A',
                    'osVersion': dev[12] or 'N/A',
                    'batteryHealth': dev[13],
                    'lastSync': dev[14].isoformat() if dev[14] else 'N/A',
                    'deviceType': 'Chromebooks',
                    'source': 'google_recent'
                }
                google_recent_devices.append(device_info)

            # Fetch Google user info to get org unit and store user data
            google_org_unit = 'N/A'
            try:
                # Try to get fresh Google user info
                google_user_info = google_client.get_user_info(email)
                if google_user_info:
                    google_org_unit = google_user_info.get('orgUnitPath', 'N/A')

                    # Store/update user in database
                    try:
                        upsert_user_query = text("""
                            INSERT INTO users (
                                user_id, email, full_name, first_name, last_name,
                                org_unit_path, is_admin, is_suspended, updated_at
                            ) VALUES (
                                :user_id, :email, :full_name, :first_name, :last_name,
                                :org_unit_path, :is_admin, :is_suspended, NOW()
                            )
                            ON CONFLICT (user_id) DO UPDATE SET
                                email = EXCLUDED.email,
                                full_name = EXCLUDED.full_name,
                                first_name = EXCLUDED.first_name,
                                last_name = EXCLUDED.last_name,
                                org_unit_path = EXCLUDED.org_unit_path,
                                is_admin = EXCLUDED.is_admin,
                                is_suspended = EXCLUDED.is_suspended,
                                updated_at = NOW()
                        """)

                        db.execute(upsert_user_query, {
                            "user_id": user_id,
                            "email": email,
                            "full_name": iiq_user.get('fullName', ''),
                            "first_name": iiq_user.get('firstName', ''),
                            "last_name": iiq_user.get('lastName', ''),
                            "org_unit_path": google_org_unit if google_org_unit != 'N/A' else None,
                            "is_admin": google_user_info.get('isAdmin', False),
                            "is_suspended": google_user_info.get('suspended', False)
                        })
                        db.commit()
                        logger.info(f"Stored/updated user {email} with org unit: {google_org_unit}")
                    except Exception as e:
                        logger.error(f"Error storing user {email}: {e}")
                        db.rollback()
                else:
                    # No Google user found, try database
                    google_user_query = text("""
                        SELECT org_unit_path FROM users WHERE LOWER(email) = LOWER(:email) LIMIT 1
                    """)
                    google_user = db.execute(google_user_query, {"email": email}).fetchone()
                    if google_user:
                        google_org_unit = google_user[0] or 'N/A'
            except Exception as e:
                logger.warning(f"Error fetching Google user info for {email}: {e}")
                # Try database as fallback
                try:
                    google_user_query = text("""
                        SELECT org_unit_path FROM users WHERE LOWER(email) = LOWER(:email) LIMIT 1
                    """)
                    google_user = db.execute(google_user_query, {"email": email}).fetchone()
                    if google_user:
                        google_org_unit = google_user[0] or 'N/A'
                except:
                    pass

            # Fetch fee balance from IIQ
            fee_info = iiq_client.get_user_fees(user_id)
            total_fee_balance = fee_info.get('total_balance', 0.0)
            logger.info(f"User {email} has fee balance: ${total_fee_balance}")

            users_list.append({
                'userId': user_id,
                'email': email,
                'fullName': iiq_user.get('fullName', 'N/A'),
                'firstName': iiq_user.get('firstName', ''),
                'lastName': iiq_user.get('lastName', ''),
                'username': iiq_user.get('username', 'N/A'),
                'isActive': iiq_user.get('isActive', True),
                'isStudent': iiq_user.get('isStudent', False),
                'studentId': iiq_user.get('studentId'),
                'location': iiq_user.get('location', 'N/A'),
                'grade': iiq_user.get('grade', 'N/A'),
                'googleOrgUnit': google_org_unit,
                'feeBalance': total_fee_balance,
                'iiqAssignedDevices': iiq_assigned_devices,
                'iiqAssignedCount': len(iiq_assigned_devices),
                'googleRecentDevices': google_recent_devices,
                'googleRecentCount': len(google_recent_devices),
                'totalDeviceCount': len(iiq_assigned_devices) + len(google_recent_devices),
                'source': 'iiq'
            })

        return {
            "users": users_list,
            "count": len(users_list)
        }

    except Exception as e:
        logger.error(f"User search error: {e}")
        raise HTTPException(status_code=500, detail=f"User search failed: {str(e)}")



@app.get("/")
async def root(request: Request, user: dict = Depends(get_current_user)):
    """Dashboard UI"""
    return templates.TemplateResponse("dashboard.html", {"request": request})

@app.get("/preview")
async def preview(request: Request, user: dict = Depends(get_current_user)):
    """Design Preview - Test new card design before applying to production"""
    import time
    response = templates.TemplateResponse("preview.html", {
        "request": request,
        "cache_bust": int(time.time())
    })
    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

@app.get("/preview-test-dec25")
async def preview_test(request: Request, user: dict = Depends(get_current_user)):
    """TEMPORARY: Test endpoint to bypass ALL caching"""
    import time
    response = templates.TemplateResponse("preview.html", {
        "request": request,
        "cache_bust": int(time.time())
    })
    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

@app.get("/dashboard")
async def dashboard(request: Request, user: dict = Depends(get_current_user)):
    """Dashboard UI (alternate route)"""
    return templates.TemplateResponse("dashboard.html", {"request": request})
